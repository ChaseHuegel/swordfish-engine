/// <auto-generated>
/// Generated by the nsd compiler. Do not modify!
/// Language version: 1
/// Source: bricks
/// </auto-generated>

#pragma warning disable CS0219 // Variable is assigned but its value is never used
#pragma warning disable CS8602 // Dereference of a possibly null reference.
using System;
using System.Buffers.Binary;

namespace WaywardBeyond.Client.Core.Serialization
{
    public struct RawBrick
    {
        #region Field identifiers
        private const ushort X_ID = 0;
        private const ushort Y_ID = 1;
        private const ushort Z_ID = 2;
        private const ushort ID_ID = 3;
        private const ushort Data_ID = 4;
        private const ushort Orientation_ID = 5;
        #endregion
        
        public int X;
        public int Y;
        public int Z;
        public ushort ID;
        public byte Data;
        public byte Orientation;
        
        public RawBrick(int _X, int _Y, int _Z, ushort _ID, byte _Data, byte _Orientation)
        {
            X = _X;
            Y = _Y;
            Z = _Z;
            ID = _ID;
            Data = _Data;
            Orientation = _Orientation;
            
        }
        
        public int GetSize()
        {
            #region Helper consts
            const int byteLen = 1;
            const int boolLen = 1;
            const int shortLen = 2;
            const int charLen = 2;
            const int intLen = 4;
            const int enumLen = 4;
            const int floatLen = 4;
            const int longLen = 8;
            const int doubleLen = 8;
            
            const int fieldHeaderLen = shortLen;
            const int optionalHeaderLen = boolLen;
            const int optionalFieldLen = fieldHeaderLen + optionalHeaderLen;
            const int arrayHeaderLen = shortLen;
            #endregion
        
            #region Static size calculation
            const int X_MinLen = fieldHeaderLen + intLen;
            const int Y_MinLen = fieldHeaderLen + intLen;
            const int Z_MinLen = fieldHeaderLen + intLen;
            const int ID_MinLen = fieldHeaderLen + shortLen;
            const int Data_MinLen = fieldHeaderLen + byteLen;
            const int Orientation_MinLen = fieldHeaderLen + byteLen;
            #endregion
        
            const int minLength = X_MinLen
                + Y_MinLen
                + Z_MinLen
                + ID_MinLen
                + Data_MinLen
                + Orientation_MinLen;
        
            int length = minLength;
        
            #region Dynamic size calculation
            #endregion
        
            return length;
        }
        
        public byte[] Serialize()
        {
            byte[] buffer = new byte[GetSize()];
            SerializeInto(buffer, 0);
            return buffer;
        }
        
        public unsafe int SerializeInto(byte[] buffer, int start)
        {
            unchecked
            {
                if (buffer.Length == 0)
                {
                    return 0;
                }
        
                fixed (byte* b = &buffer[start])
                {
                    byte* offset = b;
        
                    #region Serialize X
                    int g__X = X;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? X_ID : BinaryPrimitives.ReverseEndianness(X_ID);
                        offset += 2;
                    
                    *((int*)offset) = BitConverter.IsLittleEndian ? g__X : BinaryPrimitives.ReverseEndianness(g__X);
                        offset += 4;
                    #endregion
                    
                    #region Serialize Y
                    int g__Y = Y;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Y_ID : BinaryPrimitives.ReverseEndianness(Y_ID);
                        offset += 2;
                    
                    *((int*)offset) = BitConverter.IsLittleEndian ? g__Y : BinaryPrimitives.ReverseEndianness(g__Y);
                        offset += 4;
                    #endregion
                    
                    #region Serialize Z
                    int g__Z = Z;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Z_ID : BinaryPrimitives.ReverseEndianness(Z_ID);
                        offset += 2;
                    
                    *((int*)offset) = BitConverter.IsLittleEndian ? g__Z : BinaryPrimitives.ReverseEndianness(g__Z);
                        offset += 4;
                    #endregion
                    
                    #region Serialize ID
                    ushort g__ID = ID;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? ID_ID : BinaryPrimitives.ReverseEndianness(ID_ID);
                        offset += 2;
                    
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? g__ID : BinaryPrimitives.ReverseEndianness(g__ID);
                        offset += 2;
                    #endregion
                    
                    #region Serialize Data
                    byte g__Data = Data;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Data_ID : BinaryPrimitives.ReverseEndianness(Data_ID);
                        offset += 2;
                    
                    *((byte*)offset) = BitConverter.IsLittleEndian ? g__Data : BinaryPrimitives.ReverseEndianness(g__Data);
                        offset += 1;
                    #endregion
                    
                    #region Serialize Orientation
                    byte g__Orientation = Orientation;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Orientation_ID : BinaryPrimitives.ReverseEndianness(Orientation_ID);
                        offset += 2;
                    
                    *((byte*)offset) = BitConverter.IsLittleEndian ? g__Orientation : BinaryPrimitives.ReverseEndianness(g__Orientation);
                        offset += 1;
                    #endregion
                    
                    
        
                    return (int)(offset - b);
                }
            }
        }
        
        public int SerializeInto(Span<byte> buffer)
        {
            return SerializeInto(buffer, 0);
        }
        
        public unsafe int SerializeInto(Span<byte> buffer, int start)
        {
            unchecked
            {
                if (buffer.Length == 0)
                {
                    return 0;
                }
        
                fixed (byte* b = &buffer[start])
                {
                    byte* offset = b;
        
                    #region Serialize X
                    int g__X = X;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? X_ID : BinaryPrimitives.ReverseEndianness(X_ID);
                        offset += 2;
                    
                    *((int*)offset) = BitConverter.IsLittleEndian ? g__X : BinaryPrimitives.ReverseEndianness(g__X);
                        offset += 4;
                    #endregion
                    
                    #region Serialize Y
                    int g__Y = Y;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Y_ID : BinaryPrimitives.ReverseEndianness(Y_ID);
                        offset += 2;
                    
                    *((int*)offset) = BitConverter.IsLittleEndian ? g__Y : BinaryPrimitives.ReverseEndianness(g__Y);
                        offset += 4;
                    #endregion
                    
                    #region Serialize Z
                    int g__Z = Z;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Z_ID : BinaryPrimitives.ReverseEndianness(Z_ID);
                        offset += 2;
                    
                    *((int*)offset) = BitConverter.IsLittleEndian ? g__Z : BinaryPrimitives.ReverseEndianness(g__Z);
                        offset += 4;
                    #endregion
                    
                    #region Serialize ID
                    ushort g__ID = ID;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? ID_ID : BinaryPrimitives.ReverseEndianness(ID_ID);
                        offset += 2;
                    
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? g__ID : BinaryPrimitives.ReverseEndianness(g__ID);
                        offset += 2;
                    #endregion
                    
                    #region Serialize Data
                    byte g__Data = Data;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Data_ID : BinaryPrimitives.ReverseEndianness(Data_ID);
                        offset += 2;
                    
                    *((byte*)offset) = BitConverter.IsLittleEndian ? g__Data : BinaryPrimitives.ReverseEndianness(g__Data);
                        offset += 1;
                    #endregion
                    
                    #region Serialize Orientation
                    byte g__Orientation = Orientation;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Orientation_ID : BinaryPrimitives.ReverseEndianness(Orientation_ID);
                        offset += 2;
                    
                    *((byte*)offset) = BitConverter.IsLittleEndian ? g__Orientation : BinaryPrimitives.ReverseEndianness(g__Orientation);
                        offset += 1;
                    #endregion
                    
                    
        
                    return (int)(offset - b);
                }
            }
        }
        
        public static RawBrick Deserialize(byte[] buffer, int start, int length)
        {
            RawBrick value = new RawBrick();
            value.Unpack(buffer, start, length);
            return value;
        }
        
        public static RawBrick Deserialize(Span<byte> buffer)
        {
            RawBrick value = new RawBrick();
            value.Unpack(buffer);
            return value;
        }
        
        public static RawBrick Deserialize(ReadOnlySpan<byte> buffer)
        {
            RawBrick value = new RawBrick();
            value.Unpack(buffer);
            return value;
        }
        
        public unsafe int Unpack(byte[] buffer, int start, int length)
        {
            unchecked
            {
                if (buffer.Length == 0 || length == 0)
                {
                    return 0;
                }
        
                fixed (byte* b = &buffer[start])
                {
                    byte* end = b + length;
                    byte* offset = b;
        
                    int readsCompleted = 0;
                    bool g__X_Read = false;
                    bool g__Y_Read = false;
                    bool g__Z_Read = false;
                    bool g__ID_Read = false;
                    bool g__Data_Read = false;
                    bool g__Orientation_Read = false;
                    
        
                    while (readsCompleted < 6 && offset + 2 < end)
                    {
                        ushort id = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                        offset += 2;
        
                        switch (id)
                        {
                            #region Deserialize X
                            case X_ID:
                                if (g__X_Read)
                                {
                                    break;
                                }
                            
                                X = BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset));
                            offset += 4;
                                
                            
                                g__X_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Y
                            case Y_ID:
                                if (g__Y_Read)
                                {
                                    break;
                                }
                            
                                Y = BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset));
                            offset += 4;
                                
                            
                                g__Y_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Z
                            case Z_ID:
                                if (g__Z_Read)
                                {
                                    break;
                                }
                            
                                Z = BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset));
                            offset += 4;
                                
                            
                                g__Z_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize ID
                            case ID_ID:
                                if (g__ID_Read)
                                {
                                    break;
                                }
                            
                                ID = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                            offset += 2;
                                
                            
                                g__ID_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Data
                            case Data_ID:
                                if (g__Data_Read)
                                {
                                    break;
                                }
                            
                                Data = BitConverter.IsLittleEndian ? *((byte*)offset) : BinaryPrimitives.ReverseEndianness(*((byte*)offset));
                            offset += 1;
                                
                            
                                g__Data_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Orientation
                            case Orientation_ID:
                                if (g__Orientation_Read)
                                {
                                    break;
                                }
                            
                                Orientation = BitConverter.IsLittleEndian ? *((byte*)offset) : BinaryPrimitives.ReverseEndianness(*((byte*)offset));
                            offset += 1;
                                
                            
                                g__Orientation_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            
                        }
                    }
        
                    return (int)(offset - b);
                }
            }
        }
        
        public unsafe int Unpack(Span<byte> buffer)
        {
            return Unpack(buffer, 0, buffer.Length);
        }
        
        public unsafe int Unpack(Span<byte> buffer, int start, int length)
        {
            unchecked
            {
                if (buffer.Length == 0 || length == 0)
                {
                    return 0;
                }
        
                fixed (byte* b = &buffer[start])
                {
                    byte* end = b + length;
                    byte* offset = b;
        
                    int readsCompleted = 0;
                    bool g__X_Read = false;
                    bool g__Y_Read = false;
                    bool g__Z_Read = false;
                    bool g__ID_Read = false;
                    bool g__Data_Read = false;
                    bool g__Orientation_Read = false;
                    
        
                    while (readsCompleted < 6 && offset + 2 < end)
                    {
                        ushort id = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                        offset += 2;
        
                        switch (id)
                        {
                            #region Deserialize X
                            case X_ID:
                                if (g__X_Read)
                                {
                                    break;
                                }
                            
                                X = BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset));
                            offset += 4;
                                
                            
                                g__X_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Y
                            case Y_ID:
                                if (g__Y_Read)
                                {
                                    break;
                                }
                            
                                Y = BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset));
                            offset += 4;
                                
                            
                                g__Y_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Z
                            case Z_ID:
                                if (g__Z_Read)
                                {
                                    break;
                                }
                            
                                Z = BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset));
                            offset += 4;
                                
                            
                                g__Z_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize ID
                            case ID_ID:
                                if (g__ID_Read)
                                {
                                    break;
                                }
                            
                                ID = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                            offset += 2;
                                
                            
                                g__ID_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Data
                            case Data_ID:
                                if (g__Data_Read)
                                {
                                    break;
                                }
                            
                                Data = BitConverter.IsLittleEndian ? *((byte*)offset) : BinaryPrimitives.ReverseEndianness(*((byte*)offset));
                            offset += 1;
                                
                            
                                g__Data_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Orientation
                            case Orientation_ID:
                                if (g__Orientation_Read)
                                {
                                    break;
                                }
                            
                                Orientation = BitConverter.IsLittleEndian ? *((byte*)offset) : BinaryPrimitives.ReverseEndianness(*((byte*)offset));
                            offset += 1;
                                
                            
                                g__Orientation_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            
                        }
                    }
        
                    return (int)(offset - b);
                }
            }
        }
        
        public unsafe int Unpack(ReadOnlySpan<byte> buffer)
        {
            return Unpack(buffer, 0, buffer.Length);
        }
        
        public unsafe int Unpack(ReadOnlySpan<byte> buffer, int start, int length)
        {
            unchecked
            {
                if (buffer.Length == 0 || length == 0)
                {
                    return 0;
                }
        
                fixed (byte* b = &buffer[start])
                {
                    byte* end = b + length;
                    byte* offset = b;
        
                    int readsCompleted = 0;
                    bool g__X_Read = false;
                    bool g__Y_Read = false;
                    bool g__Z_Read = false;
                    bool g__ID_Read = false;
                    bool g__Data_Read = false;
                    bool g__Orientation_Read = false;
                    
        
                    while (readsCompleted < 6 && offset + 2 < end)
                    {
                        ushort id = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                        offset += 2;
        
                        switch (id)
                        {
                            #region Deserialize X
                            case X_ID:
                                if (g__X_Read)
                                {
                                    break;
                                }
                            
                                X = BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset));
                            offset += 4;
                                
                            
                                g__X_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Y
                            case Y_ID:
                                if (g__Y_Read)
                                {
                                    break;
                                }
                            
                                Y = BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset));
                            offset += 4;
                                
                            
                                g__Y_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Z
                            case Z_ID:
                                if (g__Z_Read)
                                {
                                    break;
                                }
                            
                                Z = BitConverter.IsLittleEndian ? *((int*)offset) : BinaryPrimitives.ReverseEndianness(*((int*)offset));
                            offset += 4;
                                
                            
                                g__Z_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize ID
                            case ID_ID:
                                if (g__ID_Read)
                                {
                                    break;
                                }
                            
                                ID = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                            offset += 2;
                                
                            
                                g__ID_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Data
                            case Data_ID:
                                if (g__Data_Read)
                                {
                                    break;
                                }
                            
                                Data = BitConverter.IsLittleEndian ? *((byte*)offset) : BinaryPrimitives.ReverseEndianness(*((byte*)offset));
                            offset += 1;
                                
                            
                                g__Data_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Orientation
                            case Orientation_ID:
                                if (g__Orientation_Read)
                                {
                                    break;
                                }
                            
                                Orientation = BitConverter.IsLittleEndian ? *((byte*)offset) : BinaryPrimitives.ReverseEndianness(*((byte*)offset));
                            offset += 1;
                                
                            
                                g__Orientation_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            
                        }
                    }
        
                    return (int)(offset - b);
                }
            }
        }
        
    }
    
    public struct RawBrickGrid
    {
        #region Field identifiers
        private const ushort Bricks_ID = 0;
        private const ushort X_ID = 1;
        private const ushort Y_ID = 2;
        private const ushort Z_ID = 3;
        private const ushort OrientationX_ID = 4;
        private const ushort OrientationY_ID = 5;
        private const ushort OrientationZ_ID = 6;
        private const ushort OrientationW_ID = 7;
        #endregion
        
        public RawBrick[] Bricks;
        public float? X;
        public float? Y;
        public float? Z;
        public float? OrientationX;
        public float? OrientationY;
        public float? OrientationZ;
        public float? OrientationW;
        
        public RawBrickGrid(RawBrick[] _Bricks, float? _X, float? _Y, float? _Z, float? _OrientationX, float? _OrientationY, float? _OrientationZ, float? _OrientationW)
        {
            Bricks = _Bricks;
            X = _X;
            Y = _Y;
            Z = _Z;
            OrientationX = _OrientationX;
            OrientationY = _OrientationY;
            OrientationZ = _OrientationZ;
            OrientationW = _OrientationW;
            
        }
        
        public int GetSize()
        {
            #region Helper consts
            const int byteLen = 1;
            const int boolLen = 1;
            const int shortLen = 2;
            const int charLen = 2;
            const int intLen = 4;
            const int enumLen = 4;
            const int floatLen = 4;
            const int longLen = 8;
            const int doubleLen = 8;
            
            const int fieldHeaderLen = shortLen;
            const int optionalHeaderLen = boolLen;
            const int optionalFieldLen = fieldHeaderLen + optionalHeaderLen;
            const int arrayHeaderLen = shortLen;
            #endregion
        
            #region Static size calculation
            const int Bricks_MinLen = fieldHeaderLen + arrayHeaderLen;
            #endregion
        
            const int minLength = Bricks_MinLen;
        
            int length = minLength;
        
            #region Dynamic size calculation
            if (Bricks != null)
            {
                for (int i = 0; i < Bricks.Length; i++)
                {
                    length += arrayHeaderLen + Bricks[i].GetSize();
                }
            }
        
            if (X != null)
            {
                length += optionalFieldLen + floatLen;
            }
        
            if (Y != null)
            {
                length += optionalFieldLen + floatLen;
            }
        
            if (Z != null)
            {
                length += optionalFieldLen + floatLen;
            }
        
            if (OrientationX != null)
            {
                length += optionalFieldLen + floatLen;
            }
        
            if (OrientationY != null)
            {
                length += optionalFieldLen + floatLen;
            }
        
            if (OrientationZ != null)
            {
                length += optionalFieldLen + floatLen;
            }
        
            if (OrientationW != null)
            {
                length += optionalFieldLen + floatLen;
            }
        
            #endregion
        
            return length;
        }
        
        public byte[] Serialize()
        {
            byte[] buffer = new byte[GetSize()];
            SerializeInto(buffer, 0);
            return buffer;
        }
        
        public unsafe int SerializeInto(byte[] buffer, int start)
        {
            unchecked
            {
                if (buffer.Length == 0)
                {
                    return 0;
                }
        
                fixed (byte* b = &buffer[start])
                {
                    byte* offset = b;
        
                    #region Serialize Bricks
                    RawBrick[] g__Bricks = Bricks;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Bricks_ID : BinaryPrimitives.ReverseEndianness(Bricks_ID);
                        offset += 2;
                    
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__Bricks?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__Bricks?.Length ?? 0));
                        offset += 2;
                    
                    for (int i = 0; i < g__Bricks?.Length; i++)
                    {
                        ushort g__Bricks_ObjectLength = (ushort)g__Bricks[i].GetSize();
                        * ((ushort*)offset) = BitConverter.IsLittleEndian ? g__Bricks_ObjectLength : BinaryPrimitives.ReverseEndianness(g__Bricks_ObjectLength);
                        offset += 2;
                    
                        g__Bricks[i].SerializeInto(buffer, (int)(offset - b));
                        offset += g__Bricks_ObjectLength;
                    }
                    #endregion
                    
                    #region Serialize X
                    float? g__X = X;
                    if (g__X != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? X_ID : BinaryPrimitives.ReverseEndianness(X_ID);
                        offset += 2;
                    
                        *((byte*)offset) = (byte)1;
                        offset += 1;
                    
                        float g__X_Copy = g__X.Value;
                    *((float*)offset) = BitConverter.IsLittleEndian ? g__X.Value : BinaryPrimitives.ReverseEndianness(*(uint*)&g__X_Copy);
                        offset += 4;
                    }
                    #endregion
                    
                    #region Serialize Y
                    float? g__Y = Y;
                    if (g__Y != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? Y_ID : BinaryPrimitives.ReverseEndianness(Y_ID);
                        offset += 2;
                    
                        *((byte*)offset) = (byte)1;
                        offset += 1;
                    
                        float g__Y_Copy = g__Y.Value;
                    *((float*)offset) = BitConverter.IsLittleEndian ? g__Y.Value : BinaryPrimitives.ReverseEndianness(*(uint*)&g__Y_Copy);
                        offset += 4;
                    }
                    #endregion
                    
                    #region Serialize Z
                    float? g__Z = Z;
                    if (g__Z != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? Z_ID : BinaryPrimitives.ReverseEndianness(Z_ID);
                        offset += 2;
                    
                        *((byte*)offset) = (byte)1;
                        offset += 1;
                    
                        float g__Z_Copy = g__Z.Value;
                    *((float*)offset) = BitConverter.IsLittleEndian ? g__Z.Value : BinaryPrimitives.ReverseEndianness(*(uint*)&g__Z_Copy);
                        offset += 4;
                    }
                    #endregion
                    
                    #region Serialize OrientationX
                    float? g__OrientationX = OrientationX;
                    if (g__OrientationX != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OrientationX_ID : BinaryPrimitives.ReverseEndianness(OrientationX_ID);
                        offset += 2;
                    
                        *((byte*)offset) = (byte)1;
                        offset += 1;
                    
                        float g__OrientationX_Copy = g__OrientationX.Value;
                    *((float*)offset) = BitConverter.IsLittleEndian ? g__OrientationX.Value : BinaryPrimitives.ReverseEndianness(*(uint*)&g__OrientationX_Copy);
                        offset += 4;
                    }
                    #endregion
                    
                    #region Serialize OrientationY
                    float? g__OrientationY = OrientationY;
                    if (g__OrientationY != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OrientationY_ID : BinaryPrimitives.ReverseEndianness(OrientationY_ID);
                        offset += 2;
                    
                        *((byte*)offset) = (byte)1;
                        offset += 1;
                    
                        float g__OrientationY_Copy = g__OrientationY.Value;
                    *((float*)offset) = BitConverter.IsLittleEndian ? g__OrientationY.Value : BinaryPrimitives.ReverseEndianness(*(uint*)&g__OrientationY_Copy);
                        offset += 4;
                    }
                    #endregion
                    
                    #region Serialize OrientationZ
                    float? g__OrientationZ = OrientationZ;
                    if (g__OrientationZ != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OrientationZ_ID : BinaryPrimitives.ReverseEndianness(OrientationZ_ID);
                        offset += 2;
                    
                        *((byte*)offset) = (byte)1;
                        offset += 1;
                    
                        float g__OrientationZ_Copy = g__OrientationZ.Value;
                    *((float*)offset) = BitConverter.IsLittleEndian ? g__OrientationZ.Value : BinaryPrimitives.ReverseEndianness(*(uint*)&g__OrientationZ_Copy);
                        offset += 4;
                    }
                    #endregion
                    
                    #region Serialize OrientationW
                    float? g__OrientationW = OrientationW;
                    if (g__OrientationW != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OrientationW_ID : BinaryPrimitives.ReverseEndianness(OrientationW_ID);
                        offset += 2;
                    
                        *((byte*)offset) = (byte)1;
                        offset += 1;
                    
                        float g__OrientationW_Copy = g__OrientationW.Value;
                    *((float*)offset) = BitConverter.IsLittleEndian ? g__OrientationW.Value : BinaryPrimitives.ReverseEndianness(*(uint*)&g__OrientationW_Copy);
                        offset += 4;
                    }
                    #endregion
                    
                    
        
                    return (int)(offset - b);
                }
            }
        }
        
        public int SerializeInto(Span<byte> buffer)
        {
            return SerializeInto(buffer, 0);
        }
        
        public unsafe int SerializeInto(Span<byte> buffer, int start)
        {
            unchecked
            {
                if (buffer.Length == 0)
                {
                    return 0;
                }
        
                fixed (byte* b = &buffer[start])
                {
                    byte* offset = b;
        
                    #region Serialize Bricks
                    RawBrick[] g__Bricks = Bricks;
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? Bricks_ID : BinaryPrimitives.ReverseEndianness(Bricks_ID);
                        offset += 2;
                    
                    *((ushort*)offset) = BitConverter.IsLittleEndian ? (ushort)(g__Bricks?.Length ?? 0) : BinaryPrimitives.ReverseEndianness((ushort)(g__Bricks?.Length ?? 0));
                        offset += 2;
                    
                    for (int i = 0; i < g__Bricks?.Length; i++)
                    {
                        ushort g__Bricks_ObjectLength = (ushort)g__Bricks[i].GetSize();
                        * ((ushort*)offset) = BitConverter.IsLittleEndian ? g__Bricks_ObjectLength : BinaryPrimitives.ReverseEndianness(g__Bricks_ObjectLength);
                        offset += 2;
                    
                        g__Bricks[i].SerializeInto(buffer, (int)(offset - b));
                        offset += g__Bricks_ObjectLength;
                    }
                    #endregion
                    
                    #region Serialize X
                    float? g__X = X;
                    if (g__X != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? X_ID : BinaryPrimitives.ReverseEndianness(X_ID);
                        offset += 2;
                    
                        *((byte*)offset) = (byte)1;
                        offset += 1;
                    
                        float g__X_Copy = g__X.Value;
                    *((float*)offset) = BitConverter.IsLittleEndian ? g__X.Value : BinaryPrimitives.ReverseEndianness(*(uint*)&g__X_Copy);
                        offset += 4;
                    }
                    #endregion
                    
                    #region Serialize Y
                    float? g__Y = Y;
                    if (g__Y != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? Y_ID : BinaryPrimitives.ReverseEndianness(Y_ID);
                        offset += 2;
                    
                        *((byte*)offset) = (byte)1;
                        offset += 1;
                    
                        float g__Y_Copy = g__Y.Value;
                    *((float*)offset) = BitConverter.IsLittleEndian ? g__Y.Value : BinaryPrimitives.ReverseEndianness(*(uint*)&g__Y_Copy);
                        offset += 4;
                    }
                    #endregion
                    
                    #region Serialize Z
                    float? g__Z = Z;
                    if (g__Z != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? Z_ID : BinaryPrimitives.ReverseEndianness(Z_ID);
                        offset += 2;
                    
                        *((byte*)offset) = (byte)1;
                        offset += 1;
                    
                        float g__Z_Copy = g__Z.Value;
                    *((float*)offset) = BitConverter.IsLittleEndian ? g__Z.Value : BinaryPrimitives.ReverseEndianness(*(uint*)&g__Z_Copy);
                        offset += 4;
                    }
                    #endregion
                    
                    #region Serialize OrientationX
                    float? g__OrientationX = OrientationX;
                    if (g__OrientationX != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OrientationX_ID : BinaryPrimitives.ReverseEndianness(OrientationX_ID);
                        offset += 2;
                    
                        *((byte*)offset) = (byte)1;
                        offset += 1;
                    
                        float g__OrientationX_Copy = g__OrientationX.Value;
                    *((float*)offset) = BitConverter.IsLittleEndian ? g__OrientationX.Value : BinaryPrimitives.ReverseEndianness(*(uint*)&g__OrientationX_Copy);
                        offset += 4;
                    }
                    #endregion
                    
                    #region Serialize OrientationY
                    float? g__OrientationY = OrientationY;
                    if (g__OrientationY != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OrientationY_ID : BinaryPrimitives.ReverseEndianness(OrientationY_ID);
                        offset += 2;
                    
                        *((byte*)offset) = (byte)1;
                        offset += 1;
                    
                        float g__OrientationY_Copy = g__OrientationY.Value;
                    *((float*)offset) = BitConverter.IsLittleEndian ? g__OrientationY.Value : BinaryPrimitives.ReverseEndianness(*(uint*)&g__OrientationY_Copy);
                        offset += 4;
                    }
                    #endregion
                    
                    #region Serialize OrientationZ
                    float? g__OrientationZ = OrientationZ;
                    if (g__OrientationZ != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OrientationZ_ID : BinaryPrimitives.ReverseEndianness(OrientationZ_ID);
                        offset += 2;
                    
                        *((byte*)offset) = (byte)1;
                        offset += 1;
                    
                        float g__OrientationZ_Copy = g__OrientationZ.Value;
                    *((float*)offset) = BitConverter.IsLittleEndian ? g__OrientationZ.Value : BinaryPrimitives.ReverseEndianness(*(uint*)&g__OrientationZ_Copy);
                        offset += 4;
                    }
                    #endregion
                    
                    #region Serialize OrientationW
                    float? g__OrientationW = OrientationW;
                    if (g__OrientationW != null)
                    {
                        *((ushort*)offset) = BitConverter.IsLittleEndian ? OrientationW_ID : BinaryPrimitives.ReverseEndianness(OrientationW_ID);
                        offset += 2;
                    
                        *((byte*)offset) = (byte)1;
                        offset += 1;
                    
                        float g__OrientationW_Copy = g__OrientationW.Value;
                    *((float*)offset) = BitConverter.IsLittleEndian ? g__OrientationW.Value : BinaryPrimitives.ReverseEndianness(*(uint*)&g__OrientationW_Copy);
                        offset += 4;
                    }
                    #endregion
                    
                    
        
                    return (int)(offset - b);
                }
            }
        }
        
        public static RawBrickGrid Deserialize(byte[] buffer, int start, int length)
        {
            RawBrickGrid value = new RawBrickGrid();
            value.Unpack(buffer, start, length);
            return value;
        }
        
        public static RawBrickGrid Deserialize(Span<byte> buffer)
        {
            RawBrickGrid value = new RawBrickGrid();
            value.Unpack(buffer);
            return value;
        }
        
        public static RawBrickGrid Deserialize(ReadOnlySpan<byte> buffer)
        {
            RawBrickGrid value = new RawBrickGrid();
            value.Unpack(buffer);
            return value;
        }
        
        public unsafe int Unpack(byte[] buffer, int start, int length)
        {
            unchecked
            {
                if (buffer.Length == 0 || length == 0)
                {
                    return 0;
                }
        
                fixed (byte* b = &buffer[start])
                {
                    byte* end = b + length;
                    byte* offset = b;
        
                    int readsCompleted = 0;
                    bool g__Bricks_Read = false;
                    bool g__X_Read = false;
                    bool g__Y_Read = false;
                    bool g__Z_Read = false;
                    bool g__OrientationX_Read = false;
                    bool g__OrientationY_Read = false;
                    bool g__OrientationZ_Read = false;
                    bool g__OrientationW_Read = false;
                    
        
                    while (readsCompleted < 8 && offset + 2 < end)
                    {
                        ushort id = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                        offset += 2;
        
                        switch (id)
                        {
                            #region Deserialize Bricks
                            case Bricks_ID:
                                if (g__Bricks_Read)
                                {
                                    break;
                                }
                            
                                ushort g__Bricks_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                            offset += 2;
                                
                                if (g__Bricks_Length == 0)
                                {
                                    Bricks = Array.Empty<RawBrick>();
                                }
                                else
                                {
                                    Bricks = new RawBrick[g__Bricks_Length];
                                
                                    for (int i = 0; i < g__Bricks_Length; i++)
                                    {
                                        ushort g__Bricks_ObjectLength = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                            offset += 2;
                            int g__Bricks_Start = (int)(offset - b);
                            Bricks[i].Unpack(buffer, g__Bricks_Start, g__Bricks_ObjectLength);
                            offset += g__Bricks_ObjectLength;
                                    }
                                }
                                
                            
                                g__Bricks_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize X
                            case X_ID:
                                if (g__X_Read)
                                {
                                    break;
                                }
                            
                                bool g__X_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__X_HasValue)
                                {
                                    uint g__X_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            X = *(float*)&g__X_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    X = null;
                                }
                                
                            
                                g__X_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Y
                            case Y_ID:
                                if (g__Y_Read)
                                {
                                    break;
                                }
                            
                                bool g__Y_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__Y_HasValue)
                                {
                                    uint g__Y_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            Y = *(float*)&g__Y_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    Y = null;
                                }
                                
                            
                                g__Y_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Z
                            case Z_ID:
                                if (g__Z_Read)
                                {
                                    break;
                                }
                            
                                bool g__Z_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__Z_HasValue)
                                {
                                    uint g__Z_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            Z = *(float*)&g__Z_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    Z = null;
                                }
                                
                            
                                g__Z_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize OrientationX
                            case OrientationX_ID:
                                if (g__OrientationX_Read)
                                {
                                    break;
                                }
                            
                                bool g__OrientationX_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__OrientationX_HasValue)
                                {
                                    uint g__OrientationX_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            OrientationX = *(float*)&g__OrientationX_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    OrientationX = null;
                                }
                                
                            
                                g__OrientationX_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize OrientationY
                            case OrientationY_ID:
                                if (g__OrientationY_Read)
                                {
                                    break;
                                }
                            
                                bool g__OrientationY_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__OrientationY_HasValue)
                                {
                                    uint g__OrientationY_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            OrientationY = *(float*)&g__OrientationY_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    OrientationY = null;
                                }
                                
                            
                                g__OrientationY_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize OrientationZ
                            case OrientationZ_ID:
                                if (g__OrientationZ_Read)
                                {
                                    break;
                                }
                            
                                bool g__OrientationZ_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__OrientationZ_HasValue)
                                {
                                    uint g__OrientationZ_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            OrientationZ = *(float*)&g__OrientationZ_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    OrientationZ = null;
                                }
                                
                            
                                g__OrientationZ_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize OrientationW
                            case OrientationW_ID:
                                if (g__OrientationW_Read)
                                {
                                    break;
                                }
                            
                                bool g__OrientationW_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__OrientationW_HasValue)
                                {
                                    uint g__OrientationW_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            OrientationW = *(float*)&g__OrientationW_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    OrientationW = null;
                                }
                                
                            
                                g__OrientationW_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            
                        }
                    }
        
                    return (int)(offset - b);
                }
            }
        }
        
        public unsafe int Unpack(Span<byte> buffer)
        {
            return Unpack(buffer, 0, buffer.Length);
        }
        
        public unsafe int Unpack(Span<byte> buffer, int start, int length)
        {
            unchecked
            {
                if (buffer.Length == 0 || length == 0)
                {
                    return 0;
                }
        
                fixed (byte* b = &buffer[start])
                {
                    byte* end = b + length;
                    byte* offset = b;
        
                    int readsCompleted = 0;
                    bool g__Bricks_Read = false;
                    bool g__X_Read = false;
                    bool g__Y_Read = false;
                    bool g__Z_Read = false;
                    bool g__OrientationX_Read = false;
                    bool g__OrientationY_Read = false;
                    bool g__OrientationZ_Read = false;
                    bool g__OrientationW_Read = false;
                    
        
                    while (readsCompleted < 8 && offset + 2 < end)
                    {
                        ushort id = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                        offset += 2;
        
                        switch (id)
                        {
                            #region Deserialize Bricks
                            case Bricks_ID:
                                if (g__Bricks_Read)
                                {
                                    break;
                                }
                            
                                ushort g__Bricks_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                            offset += 2;
                                
                                if (g__Bricks_Length == 0)
                                {
                                    Bricks = Array.Empty<RawBrick>();
                                }
                                else
                                {
                                    Bricks = new RawBrick[g__Bricks_Length];
                                
                                    for (int i = 0; i < g__Bricks_Length; i++)
                                    {
                                        ushort g__Bricks_ObjectLength = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                            offset += 2;
                            int g__Bricks_Start = (int)(offset - b);
                            Bricks[i].Unpack(buffer, g__Bricks_Start, g__Bricks_ObjectLength);
                            offset += g__Bricks_ObjectLength;
                                    }
                                }
                                
                            
                                g__Bricks_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize X
                            case X_ID:
                                if (g__X_Read)
                                {
                                    break;
                                }
                            
                                bool g__X_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__X_HasValue)
                                {
                                    uint g__X_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            X = *(float*)&g__X_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    X = null;
                                }
                                
                            
                                g__X_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Y
                            case Y_ID:
                                if (g__Y_Read)
                                {
                                    break;
                                }
                            
                                bool g__Y_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__Y_HasValue)
                                {
                                    uint g__Y_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            Y = *(float*)&g__Y_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    Y = null;
                                }
                                
                            
                                g__Y_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Z
                            case Z_ID:
                                if (g__Z_Read)
                                {
                                    break;
                                }
                            
                                bool g__Z_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__Z_HasValue)
                                {
                                    uint g__Z_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            Z = *(float*)&g__Z_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    Z = null;
                                }
                                
                            
                                g__Z_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize OrientationX
                            case OrientationX_ID:
                                if (g__OrientationX_Read)
                                {
                                    break;
                                }
                            
                                bool g__OrientationX_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__OrientationX_HasValue)
                                {
                                    uint g__OrientationX_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            OrientationX = *(float*)&g__OrientationX_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    OrientationX = null;
                                }
                                
                            
                                g__OrientationX_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize OrientationY
                            case OrientationY_ID:
                                if (g__OrientationY_Read)
                                {
                                    break;
                                }
                            
                                bool g__OrientationY_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__OrientationY_HasValue)
                                {
                                    uint g__OrientationY_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            OrientationY = *(float*)&g__OrientationY_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    OrientationY = null;
                                }
                                
                            
                                g__OrientationY_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize OrientationZ
                            case OrientationZ_ID:
                                if (g__OrientationZ_Read)
                                {
                                    break;
                                }
                            
                                bool g__OrientationZ_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__OrientationZ_HasValue)
                                {
                                    uint g__OrientationZ_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            OrientationZ = *(float*)&g__OrientationZ_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    OrientationZ = null;
                                }
                                
                            
                                g__OrientationZ_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize OrientationW
                            case OrientationW_ID:
                                if (g__OrientationW_Read)
                                {
                                    break;
                                }
                            
                                bool g__OrientationW_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__OrientationW_HasValue)
                                {
                                    uint g__OrientationW_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            OrientationW = *(float*)&g__OrientationW_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    OrientationW = null;
                                }
                                
                            
                                g__OrientationW_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            
                        }
                    }
        
                    return (int)(offset - b);
                }
            }
        }
        
        public unsafe int Unpack(ReadOnlySpan<byte> buffer)
        {
            return Unpack(buffer, 0, buffer.Length);
        }
        
        public unsafe int Unpack(ReadOnlySpan<byte> buffer, int start, int length)
        {
            unchecked
            {
                if (buffer.Length == 0 || length == 0)
                {
                    return 0;
                }
        
                fixed (byte* b = &buffer[start])
                {
                    byte* end = b + length;
                    byte* offset = b;
        
                    int readsCompleted = 0;
                    bool g__Bricks_Read = false;
                    bool g__X_Read = false;
                    bool g__Y_Read = false;
                    bool g__Z_Read = false;
                    bool g__OrientationX_Read = false;
                    bool g__OrientationY_Read = false;
                    bool g__OrientationZ_Read = false;
                    bool g__OrientationW_Read = false;
                    
        
                    while (readsCompleted < 8 && offset + 2 < end)
                    {
                        ushort id = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                        offset += 2;
        
                        switch (id)
                        {
                            #region Deserialize Bricks
                            case Bricks_ID:
                                if (g__Bricks_Read)
                                {
                                    break;
                                }
                            
                                ushort g__Bricks_Length = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                            offset += 2;
                                
                                if (g__Bricks_Length == 0)
                                {
                                    Bricks = Array.Empty<RawBrick>();
                                }
                                else
                                {
                                    Bricks = new RawBrick[g__Bricks_Length];
                                
                                    for (int i = 0; i < g__Bricks_Length; i++)
                                    {
                                        ushort g__Bricks_ObjectLength = BitConverter.IsLittleEndian ? *((ushort*)offset) : BinaryPrimitives.ReverseEndianness(*((ushort*)offset));
                            offset += 2;
                            int g__Bricks_Start = (int)(offset - b);
                            Bricks[i].Unpack(buffer, g__Bricks_Start, g__Bricks_ObjectLength);
                            offset += g__Bricks_ObjectLength;
                                    }
                                }
                                
                            
                                g__Bricks_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize X
                            case X_ID:
                                if (g__X_Read)
                                {
                                    break;
                                }
                            
                                bool g__X_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__X_HasValue)
                                {
                                    uint g__X_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            X = *(float*)&g__X_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    X = null;
                                }
                                
                            
                                g__X_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Y
                            case Y_ID:
                                if (g__Y_Read)
                                {
                                    break;
                                }
                            
                                bool g__Y_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__Y_HasValue)
                                {
                                    uint g__Y_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            Y = *(float*)&g__Y_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    Y = null;
                                }
                                
                            
                                g__Y_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize Z
                            case Z_ID:
                                if (g__Z_Read)
                                {
                                    break;
                                }
                            
                                bool g__Z_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__Z_HasValue)
                                {
                                    uint g__Z_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            Z = *(float*)&g__Z_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    Z = null;
                                }
                                
                            
                                g__Z_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize OrientationX
                            case OrientationX_ID:
                                if (g__OrientationX_Read)
                                {
                                    break;
                                }
                            
                                bool g__OrientationX_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__OrientationX_HasValue)
                                {
                                    uint g__OrientationX_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            OrientationX = *(float*)&g__OrientationX_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    OrientationX = null;
                                }
                                
                            
                                g__OrientationX_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize OrientationY
                            case OrientationY_ID:
                                if (g__OrientationY_Read)
                                {
                                    break;
                                }
                            
                                bool g__OrientationY_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__OrientationY_HasValue)
                                {
                                    uint g__OrientationY_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            OrientationY = *(float*)&g__OrientationY_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    OrientationY = null;
                                }
                                
                            
                                g__OrientationY_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize OrientationZ
                            case OrientationZ_ID:
                                if (g__OrientationZ_Read)
                                {
                                    break;
                                }
                            
                                bool g__OrientationZ_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__OrientationZ_HasValue)
                                {
                                    uint g__OrientationZ_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            OrientationZ = *(float*)&g__OrientationZ_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    OrientationZ = null;
                                }
                                
                            
                                g__OrientationZ_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            #region Deserialize OrientationW
                            case OrientationW_ID:
                                if (g__OrientationW_Read)
                                {
                                    break;
                                }
                            
                                bool g__OrientationW_HasValue = *((byte*)offset) == 0 ? false : true;
                                offset += 1;
                                
                                if (g__OrientationW_HasValue)
                                {
                                    uint g__OrientationW_Raw = BitConverter.IsLittleEndian ? *((uint*)offset) : BinaryPrimitives.ReverseEndianness(*((uint*)offset));
                            OrientationW = *(float*)&g__OrientationW_Raw;
                            offset += 4;
                                }
                                else
                                {
                                    OrientationW = null;
                                }
                                
                            
                                g__OrientationW_Read = true;
                                readsCompleted++;
                                break;
                            #endregion
                            
                            
                        }
                    }
        
                    return (int)(offset - b);
                }
            }
        }
        
    }
    
}
